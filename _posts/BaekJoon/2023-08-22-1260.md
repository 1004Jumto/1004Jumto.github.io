---
title: "[BaekJoon]1260λ²: DFSμ™€BFS"
excerpt: "[BaekJoon]1260λ²: DFS-BFS"
categories: [Baekjoon]
tags: [cpp, baekjoon, codingtest]
toc: true
toc_sticky: true
---

# DFS, BFS

## λ¬Έμ 

κ·Έλν”„λ¥Ό DFSλ΅ νƒμƒ‰ν• κ²°κ³Όμ™€ BFSλ΅ νƒμƒ‰ν• κ²°κ³Όλ¥Ό μ¶λ ¥ν•λ” ν”„λ΅κ·Έλ¨μ„ μ‘μ„±ν•μ‹μ¤. λ‹¨, λ°©λ¬Έν•  μ μλ” μ •μ μ΄ μ—¬λ¬ κ°μΈ κ²½μ°μ—λ” μ •μ  λ²νΈκ°€ μ‘μ€ κ²ƒμ„ λ¨Όμ € λ°©λ¬Έν•κ³ , λ” μ΄μƒ λ°©λ¬Έν•  μ μλ” μ μ΄ μ—†λ” κ²½μ° μΆ…λ£ν•λ‹¤. μ •μ  λ²νΈλ” 1λ²λ¶€ν„° Nλ²κΉμ§€μ΄λ‹¤.             

## μ…λ ¥

> μ²«μ§Έ μ¤„μ— μ •μ μ κ°μ N(1 β‰¤ N β‰¤ 1,000), κ°„μ„ μ κ°μ M(1 β‰¤ M β‰¤ 10,000), νƒμƒ‰μ„ μ‹μ‘ν•  μ •μ μ λ²νΈ Vκ°€ μ£Όμ–΄μ§„λ‹¤. λ‹¤μ Mκ°μ μ¤„μ—λ” κ°„μ„ μ΄ μ—°κ²°ν•λ” λ‘ μ •μ μ λ²νΈκ°€ μ£Όμ–΄μ§„λ‹¤. μ–΄λ–¤ λ‘ μ •μ  μ‚¬μ΄μ— μ—¬λ¬ κ°μ κ°„μ„ μ΄ μμ„ μ μλ‹¤. μ…λ ¥μΌλ΅ μ£Όμ–΄μ§€λ” κ°„μ„ μ€ μ–‘λ°©ν–¥μ΄λ‹¤.    

## μ¶λ ¥

> μ²«μ§Έ μ¤„μ— DFSλ¥Ό μν–‰ν• κ²°κ³Όλ¥Ό, κ·Έ λ‹¤μ μ¤„μ—λ” BFSλ¥Ό μν–‰ν• κ²°κ³Όλ¥Ό μ¶λ ¥ν•λ‹¤. Vλ¶€ν„° λ°©λ¬Έλ μ μ„ μμ„λ€λ΅ μ¶λ ¥ν•λ©΄ λλ‹¤.   

    μμ  μ…λ ¥ 1 
    4 5 1
    1 2
    1 3
    1 4
    2 4
    3 4

    μμ  μ¶λ ¥ 1 
    1 2 4 3
    1 2 3 4


## π’»μ½”λ“

```cpp
/*
* [λ°±μ¤€ 1260] DFSμ™€ BFS
* κ·Έλν”„λ¥Ό DFSλ΅ νƒμƒ‰ν• κ²°κ³Όμ™€ BFSλ΅ νƒμƒ‰ν• κ²°κ³Όλ¥Ό μ¶λ ¥ν•λ” ν”„λ΅κ·Έλ¨μ„ μ‘μ„±ν•μ‹μ¤.
* λ‹¨, λ°©λ¬Έν•  μ μλ” μ •μ μ΄ μ—¬λ¬ κ°μΈ κ²½μ°μ—λ” μ •μ  λ²νΈκ°€ μ‘μ€ κ²ƒμ„ λ¨Όμ € λ°©λ¬Έν•κ³ , 
* λ” μ΄μƒ λ°©λ¬Έν•  μ μλ” μ μ΄ μ—†λ” κ²½μ° μΆ…λ£ν•λ‹¤. μ •μ  λ²νΈλ” 1λ²λ¶€ν„° Nλ²κΉμ§€μ΄λ‹¤.

* [μ•κ³ λ¦¬μ¦]
* κΉμ΄ μ°μ„  νƒμƒ‰, λ„λΉ„ μ°μ„  νƒμƒ‰
* 
* κΉμ΄ μ°μ„  νƒμƒ‰μ€ μ¬κ·€ νΉμ€ μ¤νƒμΌλ΅ κµ¬ν„ν•  μ μλ‹¤.
* λ„λΉ„ μ°μ„  νƒμƒ‰μ€ νλ¥Ό μ¨μ„ κµ¬ν„ν•  μ μλ‹¤.
*
*/

#include<iostream>
#include<algorithm>
#include<vector>	
#include<stack>
#include<queue>

using namespace std;

int N, E, V;	// μ •μ  κ°μ, κ°„μ„  κ°μ, μ‹μ‘ μ •μ  λ²νΈ

void dfs(int start, vector<int> graph[], bool visited[]) {
	stack<int> s;
	s.push(start);
	visited[start] = true;
	cout << start << " ";

	while (!s.empty()) {
		int currentNode = s.top();
		s.pop();

		for (int i = 0; i < graph[currentNode].size(); i++) {
			int nextNode = graph[currentNode][i];
			if (!visited[nextNode]) {
				cout << nextNode << " ";
				visited[nextNode] = true;
				s.push(currentNode);
				s.push(nextNode);
				break;
			}
		}
	}
}

void dfs_recursion(int start, vector<int> graph[], bool visited[]) {
	visited[start] = true;
	cout << start << " ";
	
	for (int i = 0; i < graph[start].size(); i++) {
		int nextNode = graph[start][i];

		if (!visited[nextNode]) dfs(nextNode, graph, visited);
	}

}

void bfs(int start, vector<int> graph[], bool visited[]) {
	queue<int> q;

	q.push(start);
	visited[start] = true;

	while (!q.empty()) {
		int top = q.front();
		q.pop();
		cout << top << " ";

		for (int i = 0; i < graph[top].size(); i++) {
			if (!visited[graph[top][i]]) {
				q.push(graph[top][i]);
				visited[graph[top][i]] = true;
			}
		}
	}

}

int main(void) {
	ios::sync_with_stdio(false);
	cin.tie(NULL);
	cout.tie(NULL);

	cin >> N >> E >> V;
	vector<int>* graph = new vector<int>[N + 1];	// κ·Έλν”„ μ„ μ–Έ
	bool* visited = new bool[N + 1];				// λ°©λ¬Έ μ λ¬΄ μ €μ¥ν•λ” λ°°μ—΄ μ„ μ–Έ λ° μ΄κΈ°ν™”
	fill_n(visited, N + 1, false);

	// κ·Έλν”„ μ…λ ¥λ°›κΈ°
	for (int i = 0; i < E; i++) {
		int u, v; cin >> u >> v;
		graph[u].push_back(v);
		graph[v].push_back(u);
	}

	// μμ°¨μ  μ ‘κ·Όμ„ μ„ν•΄ μ •λ ¬
	for (int i = 1; i <= N; i++) {
		sort(graph[i].begin(), graph[i].end());
	}

	dfs(V, graph, visited);
	cout << "\n";

	fill_n(visited, N + 1, false);
	bfs(V, graph, visited);

	return 0;
}
```