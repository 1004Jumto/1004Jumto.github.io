---
title: "[C++ Programming] Chapters 1&2 : Programming and Programs"
excerpt: "[C++ Programming] 1주차 : Programming and Programs"
categories: [Cpp]
tags: [cpp, study]
toc: true
toc_sticky: true
---

## 📝This is a course

+ 문법이 목적이 아니다.
+ 더 코딩을 잘하는 방법에 초점을 맞추는 학습을 지향하며 C++은 하나의 도구로써 사용한다.
<br/>

## 📝The Aims

1. C++의 문법
2. Functional에 대한 이해도
3. 객체지향에 대한 이해도
<br/>

## 📝Why C++?

+ 가장 효율성 좋고 생산성 떨어지는 언어는 machine lang.

+ 생산성의 C
    + 운영체제(OS)를 만들기 전 생산성을 극대화하기 위해 C를 만듦
    + 운영체제 위에 모든 프로그램이 돌아가야하기 때문에 효율성이 매우 좋아야했음
    + 따라서 C와 structure lang. 이 
    + 이 때, "하드웨어의 발전은 지수함수를 따라간다" (무어의법칙)이 대두되었고 어느시기 동안 맞아떨어졌는데, 하드웨어의 발전을 소프트웨어가 따라가지 못했다. 소프트웨어는 폐쇄적이었고, 소스코드가 자산이었다. 즉 비슷한 프로그램이 있음에도 자신의 것을 처음부터 다시 만들어야 했고 소스코드의 재사용이 거의 안됐기 때문에 생산성이 매우 떨어졌다. 객체지향은 이러한 문제를 해결하는 방법이었다. 이미 만들어진 코드에 자신이 원하는 기능만 추가, 수정하여 프로그램을 만들 수 있게 되고 따라서 생산성이 향상될 수 있었다. 이러한 객체지향을 가장 적극적으로 받아들이면서 C의 효율성을 유지한 언어가 C++ 이다.  
  
+ 효율성의 C++ 
    + 약간은 geek하고 maniac하기도 함
    + 오픈소스 운동이 뜨게되면서 남의 소스코드에 접근하기 쉬워졌다. 따라서 objective-oriented의 중요도가 살짝 떨어지게 되었다.
    + 효율성을 높이기 위해선 machine dependency는 필연적이다. 하드웨어의 고유어가 다 다르다는 것으로, 하드웨어마다 그것만의 언어가 있다. 기계어는 효율성이 최고인 대신 Machine dependency도 최고조이다. 반대로, 소스코드 공유에 취약하다. 이러한 Machine dependency를 극복하기 위해 나온 언어가 JAVA이다. 가상머신을 사용함으로써, 하드웨어에 상대적으로 구속받지 않게 된다. 가상머신이 기계어로 바꿔주고 그 기계어가 실제머신에 의해 번역되어 실행되기 때문에 상대적으로 느리게 되고 효율성이 떨어질 수 있다. 그대신 소스코드의 공유가 쉬워진다. 
    + 파이썬은 인터프리터 방식이기 때문에 효율성은 좋지 않지만 코드 공유가 유리하다. 따라서 개발자 툴이 커질 수 있다. 라이브러리와 오픈소스가 많아지고 커뮤니티도 점점 커지고 생산성이 오르고 날개를 달아 날아간다. 
    + 즉, C++은 효율성 측면에서의 강자이고 대체할 수 없는 부분이 있다.  
<br/>

## 📝Why programming?

+ 1차 산업혁명 : 물리적 영역의 기계화, 증기기관
+ 2차 산업혁명 : 증기기관보다 디테일한 컨트롤이 용이한 전기, 정확도 향상, 물리적 영역의 생산성 증가
+ 3차 산업혁명 : 컴퓨터, 논리적 영역으로의 확장
+ 4차 산업혁명 : 자동화

+ 즉 3차,4차 산업혁명의 핵심인 logical한 영역에 대한 기계화가 프로그래밍에 의해 이루어진다. 가장 중요한 산업적 도구로써 매우 중요하다.
<br/>

## 📝A first program

+ 구조적 프로그래밍
    + `goto`문을 사용하지 않는 것
    + 명령어의 순차적인 1차원적 수행으로 순서가 중요해짐. 이때 `goto`문의 사용은 이러한 특성을 해치는 문장으로 사용을 지양한다.
    + 복잡한 프로그램은 순서를 생각하기 매우 어렵다. 이때 코드의 생산성을 위해 `goto(jump)`를 사용할 수 있는데, 가독성과 이해도가 떨어지고 분리가 어렵다(spagetti code). 대신 함수의 사용을 지향한다. 가독성과 이해도가 높아지고 중첩이 가능하고 오버랩이 안되고 명확해진다. 
    + **즉, C는 function을 기반으로 구현된다.**  
    + 이때 컴퓨터 입장에서는 main함수만 보이는 것으로 생각하면 된다. 
<br/>

## 📝Hello World

+ `cout` stream
<br/>

## 📝Compilation and linking

+ 컴파일러
    + 번역. 문법 확인
        + hard code 문법 : for, if와 같이 기본 C++ 문법
        + user defined 문법: user defined symbol에 대한 **선언(declaration)**. 혹은 사용자 정의 함수에 대한 선언 확인. 사용자가 지정한 문법과 하드코드 문법이 모두 맞는지 확인. 예를 들면 `int myFunc(int a, int b); myFunc(1);`과 같이 사용자가 내린 선언을 지키지 않았을 때 에러.

    + 컴파일 에러 == 문법 에러

    + 다른 소스파일들의 존재를 고려하지 않음. 하나씩 번역한다. 따라서 선언만 되어 있고, 정의되어 있지 않더라도 다른 파일에 정의되어 있을 것이라고 믿는다. 

+ 링커
    + 사용자가 정의한 변수나, symbol들은 address를 부여받아야 하는데 이 역할을 링커가 해준다. 

    + **정의(Definition)**에 symbol에 대한 주소가 주어지게 되는데, 이는 링커가 여러 개의 파일들을 읽으면서 symbol에 대채될 address를 채워준다.

    + 링킹에러 == undefined declared func, symbol