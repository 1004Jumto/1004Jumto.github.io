---
title: "[열혈 C++] Chap10: 연산자의 오버로딩1"
excerpt: "[C++] Chap10: 연산자의 오버로딩1"
categories: [Cpp]
tags: [cpp, study]
toc: true
toc_sticky: true
---

## 1. 연산자 오버로딩의 이해와 유형

### ✏️Operator+

```cpp
#include <iostream>
using namespace std;

class Point 
{
private:
	int xpos, ypos;
public:
	Point(int x=0, int y=0) : xpos(x), ypos(y)
	{  }
	void ShowPosition() const
	{
		cout<<'['<<xpos<<", "<<ypos<<']'<<endl; 
	}
	Point operator+(const Point &ref)    //operator+라는 이름의 함수
	{
		Point pos(xpos+ref.xpos, ypos+ref.ypos);
		return pos;
	}
};

int main(void)
{
	Point pos1(3, 4);
	Point pos2(10, 20);
	Point pos3=pos1.operator+(pos2);

	pos1.ShowPosition();
	pos2.ShowPosition();
	pos3.ShowPosition();
	return 0;
}
```  
  +  객체끼리 더할 수 있다.
  
  > 컴파일러는 `pos3 = pos1 + pos2` 를 `pos3=pos1.operator+(pos2)` 로 해석하여 실행한다.

  +  C++의 객체지향이 나타나는 부분 중 하나라고 생각된다. 기본 자료형 변수처럼 객체도 완벽히 기본 자료형 데이터처럼 취급할 수 있기 때문에 덧셈, 뺄셈, 나눗셈, 곱셈 등의 연산들을 가능하게 하려 한다. 

### ✏️연산자 오버로딩

+ 멤버함수에 의한 연산자 오버로딩 pos1.operator+(pos2)
+ 전역함수에 의한 연산자 오버로딩 operator+(pos1, pos2)

```cpp
#include <iostream>
using namespace std;

class Point
{
private:
	int xpos, ypos;
public:
	Point(int x=0, int y=0) : xpos(x), ypos(y)
	{  }
	void ShowPosition() const
	{
		cout<<'['<<xpos<<", "<<ypos<<']'<<endl; 
	}
	friend Point operator+(const Point &pos1, const Point &pos2);
    // friend선언을 해주면 operator+ 함수는 Point클래스의 private에 접근할 수 있게 된다.
};

Point operator+(const Point &pos1, const Point &pos2)
{
	Point pos(pos1.xpos+pos2.xpos, pos1.ypos+pos2.ypos);
	return pos;
} 

int main(void)
{
	Point pos1(3, 4);
	Point pos2(10, 20);	
	Point pos3=pos1+pos2;

	pos1.ShowPosition();
	pos2.ShowPosition();
	pos3.ShowPosition();
	return 0;
}

```
  + friend 선언을 함으로써 이 클래스는 + 연산에 대해 오버로딩이 되어있다는 정보를 쉽게 확인할 수 있다.
  + 객체지향은 전역의 개념이 없지만 c++은 C의 구현이 가능하기 때문에 전역의 개념이 남아있다. 그러나 멤버함수를 기반으로 연산자 오버로딩을 하는 것이 좋다. 

### ✏️오버로딩이 가능한 연산자

+ **멤버함수 기반으로만** 오버로딩이 가능한 연산자
    + `=` 대입연산자
    + `( )` 함수 호출 연산자
    + `[]` 배열 접근 연산자
    + `->` 멤버 접근을 위한 포인터 연산자


### ✏️주의사항

+ 본래 의도를 벗어난 형태로 오버로딩하는 것은 좋지 않다
  + `pos1+pos2`를 보고 우리가 기대하는 것은 pos1과 pos2를 더해 그 결과로 객체를 만들어 반환하는 것이다. 
  + 그러나 생뚱맞게 pos1을 pos2만큼 증가시킨다거나, 연산 결과가 pos2에 저장된다면 곤란하다

+ 매개변수 디폴트 값 설정이 불가능하다
  
+ 연산자 순수 기능까지 뺏을 순 없다
  + operator+ 인데 하는 연산은 곱셈이라던지, 여기서 이러면 안된다.

### 😀

+ 함수가 오버로딩 되고, 컴파일러는 인자로 호출을 구분한다. 이와 유사하게, 연산자가 오버로딩 되면, 피연산자의 종류에 따라 연산의 방법이 바뀐다.


## 단항 연산자 오버로딩

+ `pos++` = `pos.operator++()`(멤버함수), `operator++(pos)`(전역함수)
+  


### ✏️전위증가 후위증가 구분

> `++pos` = `pos.operator++()`
> `pos++` = `pos.operator++(int)` //후위

> `--pos` = `pos.operator--()`
> `pos--` = `pos.operator--(int)`  //후위

+ int형 인자를 전달한다는 뜻이 아니라 구분을 위해 써줌

```cpp
#include <iostream>
using namespace std;

class Point 
{
private:
	int xpos, ypos;
public:
	Point(int x=0, int y=0) : xpos(x), ypos(y)
	{  }
	void ShowPosition() const
	{
		cout<<'['<<xpos<<", "<<ypos<<']'<<endl; 
	}
	Point& operator++()         //전위 증가
	{
		xpos+=1;
		ypos+=1;
		return *this;
	}
	const Point operator++(int)     //후위 증가
	{                               
		const Point retobj(xpos, ypos);   // const Point retobj(*this);
		xpos+=1;
		ypos+=1;
		return retobj;
	}
	friend Point& operator--(Point &ref);
	friend const Point operator--(Point &ref, int);
};

//전역함수
Point& operator--(Point &ref)           //전위 감소
{
	ref.xpos-=1;
	ref.ypos-=1;
	return ref;
}

const Point operator--(Point &ref, int)     //후위 감소
{                                           
	const Point retobj(ref);
	ref.xpos-=1;
	ref.ypos-=1;
	return retobj;
}

int main(void)
{
	Point pos(3, 5);
	Point cpy;
	cpy=pos--;
	cpy.ShowPosition();
	pos.ShowPosition();

	cpy=pos++;
	cpy.ShowPosition(); 
	pos.ShowPosition();
	return 0;
}
```
   + 값을 증가 시키기 전에 객체를 복사해놓고 값을 증가시켜준다. 그러면 값은 증가되지만 복사본을 반환하면서 후위 증가의 효과를 낼 수 있다. 이때 복사본은 변경되면 안되므로 const선언을 해준다.
   +  