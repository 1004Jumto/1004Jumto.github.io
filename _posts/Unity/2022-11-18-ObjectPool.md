---
title: "[Unity] 오브젝트 풀링 Object Pool"
excerpt: "[Unity] 오브젝트 풀링 Object Pool"
categories: [Unity]
tags: [unity, polarbear, study]
toc: true
toc_sticky: true
---

## 오브젝트 풀링 Object Pool

+ 개념 : <u>필요한 오브젝트를 미리 만들어두고 필요할 때 빼서 쓰고 다 쓰면 다시 반납하도록 한다</u>

![fail to bring](/assets/Image/blog/Unity_ObjectPooling.png)

+ 더이상 빌려줄 오브젝트가 부족하면 그때서야 새로 생성하여 빌려준다. 이때 새로 생성된 오브젝트는 다시 돌려받으면 파괴하지 않고 그대로 가지고 있는다.

<br>

## 풀링을 사용하지 않을 때 발생하는 문제

1. 가비지 컬렉팅으로 인한 프레임 드랍
  + 오브젝트의 생성과 파괴는 생각보다 더 무거운 작업이다. 생성은 메모리를 새로 생성하고 리소스를 로드하는 등의 초기화과정이 필요하고, 파괴는 파괴 이후 발생하는 가비지 컬렉팅으로 인한 프레임 드랍이 발생할 수 있다
  + 가비지 컬렉팅 : c#에서 제공해주는 기능
  + Destroy로 오브젝트를 파괴할 때, 눈앞에서는 사라진 것처럼 보이지만 사실은 가비지 컬렉터가 일정사이클이 지난 뒤에 메모리를 뒤져 파괴 선언된 오브젝트를 수거한다. 그전까지는 메모리를 차지하고 있는 것이다. 렌더링과 게임 실행 등의 많은 일을 하는 와중에 수거할 오브젝트까지 많아지면 성능이 저하된다

2. 메모리 파편화
  + 처음에 메모리가 연속적으로 할당되고 실행 중 메모리가 중간중간 해제되는 경우, 새로운 메모리가 할당되려고 할 때, 그 중간에 빈 메모리 사이즈보다 크면 새롭게 채워지지 못하고 마지막 메모리 다음에 할당되게 된다. 그 이후 또 메모리를 할당할 때, 전체적으로 보면 메모리는 남지만 연속적인 메모리 공간은 없어서 메모리 할당에 실패할 수 있다.   
  즉, 메모리는 남지만 메모리가 부족한 역설적인 상황이 발생할 수 있다.