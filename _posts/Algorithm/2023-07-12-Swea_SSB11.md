---
published : true
title: "[SWEA_Self Study Book1][Array] 대표문제-Gravity"
excerpt: "[SWEA_SW 문제해결 Self Study Book Ⅰ] 1차시 배열 정의와 대표문제-Gravity 해결법 학습"
categories: [Algorithm]
tags: [cpp, algorithm, codingtest, study, swea]
toc: true
toc_sticky: true
---

❗해당 내용은 SW Expert Academy에서 제공하는 학습내용을 기반으로 하고 있습니다.  

# Array 배열

## 🗨️들어가기

서랍장이나 물품 보관함 같은 수납장은 어디든 원하는 물건을 넣을 수 있고, 위치를 알고 있으면 원하는 물건을 꺼낼 수 있다. 반대로 특정 위치를 열어 어느것에 어느 물건이 있는지 확인 할 수 있다. 이러한 기능은 물건을 분류하거나 찾기 쉽게 만들어준다. 코딩도 마찬가지로 이런 방식으로 어떤 물건을 보관 혹은 저장하는 형태를 사용한다.

## 🔖대표문제 Gravity  

![fail to bring](/assets/Image/cppStudy/selfstudybook1/gravity.png)

상자들이 쌓여있는 방이 있다. 방이 오른쪽으로 90도 회전하여 상자들이 중력의 영향을 받아 낙하한다고 할 때, 낙차가 가장 큰 상자를 구하여 그 낙차를 출력하여 보자.  
  
위의 예시에서 총 26개의 상자가 최전 후, 오른쪽 그림의 상태가 된다. A상자의 낙차가 7로 가장 크므로 7을 출력하면 된다. 회전 결과, B의 낙차는 6, C 상자의 낙차는 1이다.  
  
중력은 회전이 완료된 후 적용된다.  

+ 내가 생각한 방법은  
먼저 보드를 2차원 배열형태(행렬 X*Y)로 만든 뒤 0으로 초기화한 상태에서 블록이 쌓여진 위치에 1을 저장한다. 
그리고 행별로 마지막 열에서 시작하여 각 블록에 대한 낙차를 구한다.  
+ 1행은 블록이 없으니 넘어가고, 2행에서는 C가 낙차가 1이 될 것이고, C부터 A까지 간격(인덱스의 차이)에 C의 낙차를 더한 값이 A의 낙차가 될 것이다. 이런 식으로 각 블록에 대한 낙차를 구한 뒤 최대값을 구하면 된다.  
+ 이 때 낙차를 구하기 위해서는 처음 만들어 놓은 2차원 행렬을 재탕하고, 최대값을 구하기 위해 구한 낙차값들을 따로 저장하기 위한 벡터를 만들면 될 것 같다.  

## 📑배열

위의 문제를 풀기 위해서는 배열을 이해해야 한다. 

배열을 사용하는 이유는 여러 개의 int형 변수가 필요하다고 할 때, `int num0; int num1; ... int num8;` 이런 식으로 변수를 선언한다면 저 변수들 사이에 어떤 수가 존재하는지 알아보려 할 때 조건문으로 일일이 하나하나 확인해야하는 귀찮은 일이 생긴다. 

그러나 `int arr[9]`이런 식으로 배열을 선언한다면 기존보다 훨씬 간편해진다. 또한 배열은 **연속적으로 메모리가 할당**되기 때문에 인덱스를 사용하여 차례차례 접근하기 쉬워진다.  
`Arr[0] =10;` `for(int i=0; i<arr.length();i++` 이렇게 간결하게 사용할 수 있다.  
  
추가적으로 2차원 배열을 선언할 수 있는데, 그렇다고 배열이 실제로 2차원 공간에 메모리가 할당 되는 것은 아니다. 만약 `Arr[4][5]` 선언했을 때, 4*5만큼 크기가 메모리에 연속적으로 할당되고, 코딩을 할 때 개발자들이 좀 더 편리하게 2차원적 개념으로 변수에 접근할 수 있게 된다.  
마찬가지로 2차원 배열만이 아니라 다차원 배열을 선언할 수 있으며, 이를 활용하여 다양한 문제 풀이 전략을 세울 수 있다.


## ⚙️대표문제 Gravity 해결하기

![fail to bring](/assets/Image/cppStudy/selfstudybook1/gravity.png)

#### 입력 

첫 번째 줄에 test case의 수 T(1≤T≤100) 가 주어진다. 각 케이스의 첫째 줄에 방의 가로 길이 N(2≤N≤100)과 방의 세로 길이 M(2≤M≤100) 이 주어진다. 다음 줄에는 N개의 상자들이 쌓여 있는 높이 H(0≤H≤M)가 주어진다.

```
1                       // 테스트케이스T의개수
9 8                     // 방의가로길이N, 방의세로길이M
7 4 2 0 0 6 0 7 0       // 상자들이쌓여있는높이
```

#### 출력

낙차가 가장 큰 값을 출력 한다.

```
7
```

#### 해설

방은 2차원 배열을 사용하여 저장한다. 또한 오른쪽으로 90도 회전 한 값을 따로 저장하는 방법보다는 입력으로 받은 값을 회전했다고 취급한다. 회전은 2차원 배열에서 행과 열이 바뀌는 것과 같다.  

해설에서 설명한 가장 쉽게 생각할 수 있는 방법은 내가 위에서 생각한 방법처럼 2차원 배열을 선언한 뒤 상자를 1과 0으로 채우는 것이다. 

![fail to bring](/assets/Image/cppStudy/selfstudybook1/gravity2.png)

방이 오른쪽으로 회전하면 상자들이 오른쪽 정렬되는 것과 같다. 따라서 상자 오른쪽에 있는 빈칸 개수가 이동하는 거리와 같다. 나는 맨 오른쪽 상자부터 낙차를 구해 왼편에 있는 블록과 인덱스 차이를 더해가며 블록의 낙차를 구해가는 생각을 했는데 그게 생각해보니 0의 개수와 같은 것이었다. 따라서 오른쪽 빈칸 수를 각 블록에 대해 구하고 최댓값을 구하면 된다.  
이 방법은 시간 복잡도가 **O(n^3)**이다. 빠른 건 아니고 방의 크기가 커지면 꽤 오래 시간이 걸릴 것이다.  

조금 더 생각해보면 사실 낙차가 가장 큰 상자는 위쪽에서 나올 확률이 크다는 것이다. 가장 최대값의 낙차를 가지려면 가장 위의 상자만이 최대 낙차를 가질 수 있다는 특징을 알아낸다면 더 효율적으로 빠르게 풀 수 있다.  

이런 식으로 문제를 풀 때 내가 직접 문제를 푸는 머릿속 사고 과정이 알고리즘이 될 수 있지만, 더 나아가 답이 될 수 있는 특성을 생각해보는 것이 꼭 필요하다.  

### Code

```cpp

#include<iostream>
#include<vector>
#include<algorithm>

using namespace std;

#define EMPTY 0
#define BOX 1

int main(void) {
	int T = 0;							// testcase
	int roomWidth, roomHeight = 0;		// width, height of room

	
	cin >> T;

	for (int t = 0; t < T; t++) {
		
		vector<int> tmp;
		vector<int> boxHeight;				// height of boxes
		vector<vector<int>>room;
		int countOfEmpty = 0;
		int max = 0;

		cin >> roomWidth >> roomHeight;

		// 방 초기화
		for (int i = 0; i < roomHeight; i++) tmp.push_back(EMPTY);
		for (int i = 0; i < roomWidth; i++) room.push_back(tmp);
	
		// 상자 채우기
		for (int i = 0; i < roomWidth; i++) {		
			int H;  cin >> H; boxHeight.push_back(H);
			for (int j = 0; j < H; j++) {
				room[i][j] = BOX;
			}
		}

		// 각 열마다 맨 위 상자의 낙차를 구한다
		for (int i = 0; i < roomWidth; i++) {
			if (boxHeight[i] > 0) {
				countOfEmpty = 0;
				for (int j = i + 1; j < roomWidth; j++) {
					if (room[j][boxHeight[i] - 1] == EMPTY) countOfEmpty++;
				}
				if (max < countOfEmpty) max = countOfEmpty;
			}
		}

		cout << max << endl;
	}
	return 0;
}
```  

인덱스를 다루는 것은 언제나 헷갈리기 때문에 차분히 그림으로 놓고 생각해보는 것이 도움이 된다.  
위의 코드에서는 문제를 풀기 위해 2차원 배열 사이즈를 만들고 초기화 할 때, width가 세로가 되고 height가 가로가 되도록 했다. 행과 열 위치를 바꾼셈. 오른쪽으로 회전한 모양으로 초기화하고 상자를 채워준 셈이 된다.
